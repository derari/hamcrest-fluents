def propertyChainMethods(iface, ret) {
    def override = !iface.name.endsWith("FluentProperty")
    ["is", "has"].each { c ->
        iface.method(c, returns: ret) {
            comment = """Prepends "%s" to the next matcher's description.""" % name
            tags << "return this"
            if (override) annotations << "Override"
        }
    }
    iface.method("not", returns: ret) {
        comment = """Negates the next matcher's result and prepends "not" to its description."""
        tags << "return this"
        if (override) annotations << "Override"
    }
}

api1 {

    def clFluentProperty
    def clFluent = "org.cthul.matchers.fluent.Fluent".asClass()

    generatedInterface ("FluentProperty") {
        clFluentProperty = it;
        comment = "Fluent that matches a property of a value.\n<p>\nAfter the match, the fluent chain goes back to the value itself."
        tags << "param <Value> type of actual value"
        tags << "param <Property> type of property to be matched"
        typeParameters << ["Value", "Property"]
        
        propertyChainMethods(it, it.withArgs("Value", "Property"))
    }

    generatedInterface ("Fluent") {
        clFluent = it;
        comment = "Base interface for fluent matcher chains.\nSee {@link FluentMatcher} and {@link FluentAssert} for concrete use-cases.\n<p>\nAs a {@linkplain FluentProperty property}, it matches against the value itself."
        tags << "param <Value> type of value to be matched"
        typeParameters << "Value"
        superClass = clFluentProperty.withArgs("Value", "Value")
        
        propertyChainMethods(it, it.withArgs("Value"))
    }
}